from fastapi import FastAPI, HTTPException, Header,Request
from pydantic import BaseModel
#import sqlalchemy
#from sqlalchemy import create_engine, text
import os

app = FastAPI(title="EcomOps External Data Gateway")

# --- TENANT DATABASE REGISTRY ---
# In production, move these to an encrypted database or Environment Variables
DB_REGISTRY = {
    "company_alpha": "postgresql://user:pass@alpha-db.example.com:5432/inventory",
    "company_beta": "mysql+pymysql://user:pass@beta-server.com:3306/shop_data",
    "company_gamma": "sqlite:///./gamma_local.db" # Example for testing
}

class ToolRequest(BaseModel):
    company_id: str
    query: str  # The SQL or ESQL generated by the Agent
    operation_type: str = "read" # "read" or "write"

""""
@app.post("/execute")
async def execute_tool(request: ToolRequest):
    # 1. Tenant Validation
    if request.company_id not in DB_REGISTRY:
        raise HTTPException(status_code=403, detail="Unauthorized: Company ID not recognized.")

    # 2. Get the specific connection string
    connection_string = DB_REGISTRY[request.company_id]
    
    try:
        # 3. Create a temporary engine and execute
        # (For production, use a connection pool to improve speed)
        engine = create_engine(connection_string)
        
        with engine.connect() as connection:
            # Check for safety: Don't allow DROPs or DELETEs via the read tool
            if request.operation_type == "read" and any(word in request.query.upper() for word in ["DROP", "DELETE", "TRUNCATE"]):
                raise HTTPException(status_code=400, detail="Security Violation: Unauthorized SQL command.")

            result = connection.execute(text(request.query))
            
            # 4. Format the result for the LLM
            columns = result.keys()
            data = [dict(zip(columns, row)) for row in result.fetchall()]
            
            return {
                "status": "success",
                "company_id": request.company_id,
                "data": data,
                "row_count": len(data)
            }

    except Exception as e:
        return {"status": "error", "message": str(e)}

@app.post("/actions/order-update")
async def update_order(order_id: str, new_status: str, company_id: str):
    # 1. Validation Logic
    if new_status == "CANCELLED":
        # Check if the order is already shipped
        current_status = get_status_from_db(order_id, company_id)
        if current_status == "SHIPPED":
            return {"status": "error", "message": "Cannot cancel an order already in transit."}
    
    # 2. Execute standardized Update
    db_update(order_id, new_status, company_id)
    return {"status": "success", "message": f"Order {order_id} set to {new_status}"}
    
"""
@app.get("/list_tools")
async def list_tools():
    return {
        "tools": [
            {
                "name": "ecomops_search",
                "description": "Searches inventory, orders, and customers.",
                "inputSchema": {
                    "type": "object",
                    "properties": {
                        "query_type": {"type": "string", "enum": ["inventory", "orders", "customers"]},
                        "search_term": {"type": "string"}
                    },
                    "required": ["query_type", "search_term"]
                }
            }
        ]
    }

# 2. Execution: This is the "Action" endpoint Elastic POSTs to
# Check your Connector URL in Elastic: it should end in /tools/call
@app.post("/mcp/call")
async def call_tool(request: Request):
    body = await request.json()
    
    # Elastic sends the tool name and arguments in this format
    tool_name = body.get("name")
    arguments = body.get("arguments", {})
    
    if tool_name == "ecomops_search":
        q_type = arguments.get("query_type")
        term = arguments.get("search_term")
        
        # This is the format MCP expects for a response
        return {
            "content": [
                {
                    "type": "text",
                    "text": f"Found results for {term} in {q_type}: [Sample Data]"
                }
            ]
        }
    
    return {"error": "Tool not found"}, 404
    
@app.post("/")
async def mcp_handler(request: Request):
    body = await request.json()
    request_id = body.get("id")
    method = body.get("method")

    # STEP 1: The Handshake (Fixes your current error)
    if method == "initialize":
        return {
            "jsonrpc": "2.0",
            "id": request_id,
            "result": {
                "protocolVersion": "2024-11-05",  # Explicitly required string
                "capabilities": {
                    "tools": {},       # Tell Elastic we have tools
                    "resources": {},
                    "prompts": {}
                },
                "serverInfo": {
                    "name": "EcomOps-Gateway",
                    "version": "1.0.0"
                }
            }
        }

    # STEP 2: The Confirmation (Elastic sends this after initialize)
    elif method == "notifications/initialized":
        return None # Notifications don't need a response

    # STEP 3: The Tool List (Discovery)
    elif method == "tools/list":
        return {
            "jsonrpc": "2.0",
            "id": request_id,
            "result": {
                "tools": [
                    {
                        "name": "ecomops_search",
                        "description": "Search inventory and orders.",
                        "inputSchema": {
                            "type": "object",
                            "properties": {
                                "query_type": {"type": "string", "enum": ["inventory", "orders"]},
                                "search_term": {"type": "string"}
                            },
                            "required": ["query_type", "search_term"]
                        }
                    }, 
                    {
                        "name": "ecomops_analytics",
                        "description": "Calculates business metrics like total revenue or stock summaries.",
                        "inputSchema": {
                            "type": "object",
                            "properties": {
                                "metric_type": {
                                    "type": "string", 
                                    "enum": ["total_revenue", "avg_order_value", "stock_count"]
                                },
                                "category": {"type": "string"}
                            },
                            "required": ["metric_type"]
                        }
                    },
                    {
                    "name": "ecomops_workflow",
                    "description": "Triggers automated workflows like sending notifications or updating order statuses.",
                    "inputSchema": {
                        "type": "object",
                        "properties": {
                            "action_type": {
                                "type": "string", 
                                "enum": ["notify_warehouse", "flag_fraud", "send_customer_email"],
                                "description": "The automated action to trigger"
                            },
                            "target_id": {
                                "type": "string",
                                "description": "The Order ID or Product ID related to this action"
                            },
                            "priority": {
                                "type": "string",
                                "enum": ["high", "medium", "low"]
                            }
                        },
                        "required": ["action_type", "target_id"]
                    }
                },
                    {
                    "name": "ecomops_external_api",
                    "description": "Fetches real-time data from external providers like currency rates or shipping tracking.",
                    "inputSchema": {
                        "type": "object",
                        "properties": {
                            "provider": {
                                "type": "string", 
                                "enum": ["currency_converter", "shipping_tracker"],
                                "description": "The external service to query"
                            },
                            "query_params": {
                                "type": "string",
                                "description": "The specific ID or currency code (e.g., 'USD' or 'TRACK123')"
                            }
                        },
                        "required": ["provider", "query_params"]
                    }
                },
                    {
                    "name": "ecomops_memory",
                    "description": "Saves or retrieves persistent information about user preferences, system notes, or recurring issues.",
                    "inputSchema": {
                        "type": "object",
                        "properties": {
                            "action": {
                                "type": "string", 
                                "enum": ["save", "recall"],
                                "description": "Whether to store a new memory or search for old ones."
                            },
                            "note_content": {
                                "type": "string",
                                "description": "The information to remember (required for 'save')."
                            },
                            "topic": {
                                "type": "string",
                                "description": "The category (e.g., 'user_preference', 'system_config', 'vip_customer')."
                            }
                        },
                        "required": ["action", "topic"]
                    }
                },
                    
                    {
                    "name": "ecomops_alerting",
                    "description": "Sets up or triggers real-time alerts for business metrics and system status.",
                    "inputSchema": {
                        "type": "object",
                        "properties": {
                            "alert_name": {
                                "type": "string",
                                "description": "A nickname for the alert (e.g., 'Low Stock Warning')."
                            },
                            "condition": {
                                "type": "string",
                                "description": "The threshold or event that triggers the alert (e.g., 'stock < 5')."
                            },
                            "channel": {
                                "type": "string", 
                                "enum": ["slack", "email", "sms"],
                                "description": "Where to send the notification."
                            }
                        },
                        "required": ["alert_name", "condition", "channel"]
                    }
                },
                    {
                "name": "ecomops_audit_log",
                "description": "Records important AI actions, tool usage, and system changes for security and tracking.",
                "inputSchema": {
                    "type": "object",
                    "properties": {
                        "event_type": {
                            "type": "string", 
                            "enum": ["tool_execution", "security_alert", "data_change", "user_override"],
                            "description": "The category of the event being logged."
                        },
                        "description": {
                            "type": "string",
                            "description": "A detailed summary of what the AI did (e.g., 'Triggered Slack alert for Order #101')."
                        },
                        "status": {
                            "type": "string",
                            "enum": ["success", "failure", "pending"]
                        }
                    },
                    "required": ["event_type", "description", "status"]
                }
            }
                ]
            }
        }

    # STEP 4: Handle the execution of DIFFERENT tools
    elif method == "tools/call":
        params = body.get("params", {})
        tool_name = params.get("name") # Get the name of the tool being called
        args = params.get("arguments", {})
        
        if tool_name == "ecomops_search":
            q_type = args.get("query_type")
            term = args.get("search_term")
            response_text = f"Searching the {q_type} database for '{term}'... [No real data yet]"
            
        elif tool_name == "ecomops_analytics":
            metric = args.get("metric_type")
            response_text = f"Analyzing {metric}... The current calculated value is 0.00."
        
        elif tool_name == "ecomops_workflow":
        action = args.get("action_type")
        item_id = args.get("target_id")
        priority = args.get("priority", "medium")
        
        elif tool_name == "ecomops_external_api":
            provider = args.get("provider")
            query = args.get("query_params")

            if provider == "currency_converter":
                # Imagine calling: https://api.exchangerate.host/latest
                rate = 0.92  # Mock rate for USD to EUR
                response_text = f"The current exchange rate for {query} is {rate}."
                
            elif provider == "shipping_tracker":
                # Imagine calling a Shipping API
                status = "In Transit - Expected Delivery: Friday"
                response_text = f"Shipping status for {query}: {status}."
            
            else:
                response_text = "External provider not recognized."
                
        elif tool_name == "ecomops_memory":
            action = args.get("action")
            topic = args.get("topic")
            content = args.get("note_content")

            if action == "save":
                # logic: INSERT INTO memory (topic, content) VALUES (topic, content)
                print(f"ðŸ§  MEMORY STORED: [{topic}] {content}")
                response_text = f"I've noted that for you under '{topic}'."
                
            elif action == "recall":
                # logic: SELECT content FROM memory WHERE topic = topic
                # Mocking a recalled memory
                if topic == "user_preference":
                    response_text = "Previous note: User prefers FedEx for all high-priority shipping."
                else:
                    response_text = f"I don't have any specific notes under '{topic}' yet."
        
        elif tool_name == "ecomops_alerting":
            name = args.get("alert_name")
            cond = args.get("condition")
            channel = args.get("channel")   
        
        elif tool_name == "ecomops_audit_log":
            event = args.get("event_type")
            desc = args.get("description")
            stat = args.get("status")       
        else:
            response_text = "Unknown tool called."

        return {
            "jsonrpc": "2.0",
            "id": request_id,
            "result": {
                "content": [{"type": "text", "text": response_text}]
            }
        }
if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8001) # Running on 8001 to avoid conflict with Chat Backend